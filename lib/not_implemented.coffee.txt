fs = require("fs")
protocol = {}
protocol.init = builder.init
protocol.status = methodBuilder(
  method: "GET"
  absPath: ->
    @basePath + "/status"

  cb: (cb) ->
    callbackWithData cb
)
protocol.sessions = methodBuilder(
  method: "GET"
  absPath: ->
    @basePath + "/sessions"

  cb: (cb) ->
    callbackWithData cb
)
protocol.altSessionCapabilities = (cb) ->
  _this = this
  protocol.sessions.apply this, [ (err, sessions) ->
    unless err?
      sessions = sessions.filter((session) ->
        session.id is _this.sessionID
      )
      _ref = undefined
      cb null, (if (_ref = sessions[0])? then _ref.capabilities else undefined)
    else
      cb err, sessions
   ]

protocol.sessionCapabilities = methodBuilder(
  method: "GET"
  cb: (cb) ->
    callbackWithData cb
)
protocol.close = methodBuilder(
  method: "DELETE"
  relPath: "/window"
)
protocol.quit = methodBuilder(
  method: "DELETE"
  emit:
    event: "status"
    message: "\nEnding your web drivage..\n"
)
protocol.eval = (code, cb) ->
  code = "return " + code + ";"
  protocol.execute.apply this, [ code, (err, res) ->
    return cb(err)  if err?
    cb null, res
   ]

protocol.safeEval = (code, cb) ->
  protocol.safeExecute.apply this, [ code, (err, res) ->
    return cb(err)  if err?
    cb null, res
   ]

protocol.execute = methodBuilder(
  method: "POST"
  relPath: "/execute"
  cb: ->
    cb = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    callbackWithData cb

  data: ->
    args = undefined
    cb = undefined
    code = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    code = _args[0]
    args = _args[1]

    args = []  if typeof args is "undefined" or args is null
    script: code
    args: args
)
safeExecuteJsScript = fs.readFileSync(__dirname + "/browser-scripts/safe-execute.js", "utf8")
protocol.safeExecute = methodBuilder(
  method: "POST"
  relPath: "/execute"
  cb: ->
    cb = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    callbackWithData cb

  data: ->
    args = undefined
    cb = undefined
    code = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    code = _args[0]
    args = _args[1]

    args = []  if typeof args is "undefined" or args is null
    script: safeExecuteJsScript
    args: [ code, args ]
)
protocol.executeAsync = methodBuilder(
  method: "POST"
  relPath: "/execute_async"
  cb: ->
    cb = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    callbackWithData cb

  data: (code) ->
    args = undefined
    cb = undefined
    code = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    code = _args[0]
    args = _args[1]

    args = []  if typeof args is "undefined" or args is null
    script: code
    args: args
)
safeExecuteAsyncJsScript = fs.readFileSync(__dirname + "/browser-scripts/safe-execute-async.js", "utf8")
protocol.safeExecuteAsync = methodBuilder(
  method: "POST"
  relPath: "/execute_async"
  cb: ->
    cb = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    callbackWithData cb

  data: (code) ->
    args = undefined
    cb = undefined
    code = undefined
    _args = undefined
    _i = undefined
    _args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
    []
    ))
    cb = arguments[_i++]

    code = _args[0]
    args = _args[1]

    args = []  if typeof args is "undefined" or args is null
    script: safeExecuteAsyncJsScript
    args: [ code, args ]
)
protocol.get = methodBuilder(
  method: "POST"
  relPath: "/url"
  data: (url) ->
    url: url
)
protocol.refresh = methodBuilder(
  method: "POST"
  relPath: "/refresh"
)
protocol.forward = methodBuilder(
  method: "POST"
  relPath: "/forward"
)
protocol.back = methodBuilder(
  method: "POST"
  relPath: "/back"
)
protocol.setImplicitWaitTimeout = methodBuilder(
  method: "POST"
  relPath: "/timeouts/implicit_wait"
  data: (ms) ->
    ms: ms
)
protocol.setWaitTimeout = protocol.setImplicitWaitTimeout
protocol.setAsyncScriptTimeout = methodBuilder(
  method: "POST"
  relPath: "/timeouts/async_script"
  data: (ms) ->
    ms: ms
)
protocol.setPageLoadTimeout = methodBuilder(
  method: "POST"
  relPath: "/timeouts/timeouts"
  data: (ms) ->
    type: "page load"
    ms: ms
)
protocol.element = methodBuilder(
  method: "POST"
  relPath: "/element"
  cb: (using, value, cb) ->
    elementCallback cb

  data: (using, value) ->
    using: using
    value: value
)
protocol.elementOrNull = (using, value, cb) ->
  protocol.elements.apply this, [ using, value, (err, elements) ->
    unless err?
      if elements.length > 0
        cb null, elements[0]
      else
        cb null, null
    else
      cb err
   ]

protocol.elementIfExists = (using, value, cb) ->
  protocol.elements.apply this, [ using, value, (err, elements) ->
    unless err?
      if elements.length > 0
        cb null, elements[0]
      else
        cb null, `undefined`
    else
      cb err
   ]

protocol.elements = methodBuilder(
  method: "POST"
  relPath: "/elements"
  cb: (using, value, cb) ->
    elementsCallback cb

  data: (using, value) ->
    using: using
    value: value
)
protocol.hasElement = (using, value, cb) ->
  protocol.elements.apply this, [ using, value, (err, elements) ->
    unless err?
      cb null, elements.length > 0
    else
      cb err
   ]

elFuncSuffix = (type) ->
  res = (" by " + type).replace(/(\s[a-z])/g, ($1) ->
    $1.toUpperCase().replace " ", ""
  )
  res.replace "Xpath", "XPath"

elFuncFullType = (type) ->
  return "css selector"  if type is "css"
  type

elementFuncTypes = [ "class name", "css selector", "id", "name", "link text", "partial link text", "tag name", "xpath", "css" ]
i = 0

while i < elementFuncTypes.length
  (->
    type = elementFuncTypes[i]
    protocol["element" + elFuncSuffix(type)] = (value, cb) ->
      protocol.element.apply this, [ elFuncFullType(type), value, cb ]

    protocol["element" + elFuncSuffix(type) + "OrNull"] = (value, cb) ->
      protocol.elements.apply this, [ elFuncFullType(type), value, (err, elements) ->
        unless err?
          if elements.length > 0
            cb null, elements[0]
          else
            cb null, null
        else
          cb err
       ]

    protocol["element" + elFuncSuffix(type) + "IfExists"] = (value, cb) ->
      protocol.elements.apply this, [ elFuncFullType(type), value, (err, elements) ->
        unless err?
          if elements.length > 0
            cb null, elements[0]
          else
            cb null, `undefined`
        else
          cb err
       ]

    protocol["hasElement" + elFuncSuffix(type)] = (value, cb) ->
      protocol.hasElement.apply this, [ elFuncFullType(type), value, cb ]

    protocol["elements" + elFuncSuffix(type)] = (value, cb) ->
      protocol.elements.apply this, [ elFuncFullType(type), value, cb ]
  )()
  i++
protocol.getAttribute = methodBuilder(
  method: "GET"
  relPath: (element, attrName) ->
    "/element/" + element + "/attribute/" + attrName

  cb: (element, attrName, cb) ->
    callbackWithData cb
)
protocol.getValue = (element, cb) ->
  protocol.getAttribute.apply this, [ element, "value", cb ]

protocol.clickElement = methodBuilder(
  method: "POST"
  relPath: (element, attrName) ->
    "/element/" + element + "/click"
)
protocol.moveTo = methodBuilder(
  method: "POST"
  relPath: "/moveto"
  data: (element, xoffset, yoffset) ->
    element: element
    xoffset: xoffset
    yoffset: yoffset
)
protocol.buttonDown = methodBuilder(
  method: "POST"
  relPath: "/buttondown"
)
protocol.buttonUp = methodBuilder(
  method: "POST"
  relPath: "/buttonup"
)
protocol.click = methodBuilder(
  method: "POST"
  relPath: "/click"
  data: (button) ->
    button: button
)
protocol.doubleclick = methodBuilder(
  method: "POST"
  relPath: "/doubleclick"
)
protocol.type = methodBuilder(
  method: "POST"
  relPath: (element, keys) ->
    "/element/" + element + "/value"

  data: (element, keys) ->
    keys = [ keys ]  unless keys instanceof Array
    value: keys
)
protocol.keys = methodBuilder(
  method: "POST"
  relPath: "/keys"
  data: (keys) ->
    keys = [ keys ]  unless keys instanceof Array
    value: keys
)
protocol.clear = methodBuilder(
  method: "POST"
  relPath: (element) ->
    "/element/" + element + "/clear"
)
protocol.title = methodBuilder(
  method: "GET"
  relPath: "/title"
  cb: (cb) ->
    callbackWithData cb
)
_rawText = methodBuilder(
  method: "GET"
  relPath: (element) ->
    "/element/" + element + "/text"

  cb: (element, cb) ->
    callbackWithData cb
)
protocol.text = (element, cb) ->
  _this = this
  if typeof element is "undefined" or element is "body" or element is null
    protocol.element.apply this, [ "tag name", "body", (err, bodyEl) ->
      unless err?
        _rawText.apply _this, [ bodyEl, cb ]
      else
        cb err
     ]
  else
    _rawText.apply _this, [ element, cb ]

protocol.textPresent = (searchText, element, cb) ->
  protocol.text.apply this, [ element, (err, text) ->
    if err
      cb err, null
    else
      cb err, text.indexOf(searchText) >= 0
   ]

protocol.acceptAlert = methodBuilder(
  method: "POST"
  relPath: "/accept_alert"
)
protocol.dismissAlert = methodBuilder(
  method: "POST"
  relPath: "/dismiss_alert"
)
protocol.active = methodBuilder(
  method: "POST"
  relPath: "/element/active"
  cb: (cb) ->
    callbackWithData (e, o) ->
      cb null, o["ELEMENT"]
)
protocol.url = methodBuilder(
  method: "GET"
  relPath: "/url"
  cb: (cb) ->
    callbackWithData cb
)
protocol.allCookies = methodBuilder(
  method: "GET"
  relPath: "/cookie"
  cb: (cb) ->
    callbackWithData cb
)
protocol.setCookie = methodBuilder(
  method: "POST"
  relPath: "/cookie"
  data: (cookie) ->
    cookie.secure = false  if (typeof cookie isnt "undefined" and cookie isnt null) and ((if typeof cookie isnt "undefined" and cookie isnt null then cookie.secure else undefined)?)
    cookie: cookie
)
protocol.deleteAllCookies = methodBuilder(
  method: "DELETE"
  relPath: "/cookie"
)
protocol.deleteCookie = methodBuilder(
  method: "DELETE"
  relPath: (name) ->
    "/cookie/" + encodeURIComponent(name)
)
waitForConditionImpl = (conditionExpr, limit, poll, cb) ->
  _this = this
  if Date.now() < limit
    protocol.safeEval.apply _this, [ conditionExpr, (err, res) ->
      return cb(err)  if err?
      if res is true
        cb null, true
      else
        setTimeout (->
          waitForConditionImpl.apply _this, [ conditionExpr, limit, poll, cb ]
        ), poll
     ]
  else
    protocol.safeEval.apply _this, [ conditionExpr, (err, res) ->
      return cb(err)  if err?
      if res is true
        cb null, true
      else
        cb "waitForCondition failure for: " + conditionExpr
     ]

protocol.waitForCondition = ->
  args = undefined
  cb = undefined
  conditionExpr = undefined
  limit = undefined
  poll = undefined
  timeout = undefined
  _i = undefined
  args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
  []
  ))
  cb = arguments[_i++]

  conditionExpr = args[0]
  timeout = args[1]
  poll = args[2]

  timeout = timeout or 1000
  poll = poll or 100
  limit = Date.now() + timeout
  waitForConditionImpl.apply this, [ conditionExpr, limit, poll, cb ]

waitForConditionInBrowserJsScript = fs.readFileSync(__dirname + "/browser-scripts/wait-for-cond-in-browser.js", "utf8")
protocol.waitForConditionInBrowser = ->
  _this = this
  args = undefined
  cb = undefined
  conditionExpr = undefined
  limit = undefined
  poll = undefined
  timeout = undefined
  _i = undefined
  args = (if 2 <= arguments.length then __slice_.call(arguments, 0, _i = arguments.length - 1) else (_i = 0
  []
  ))
  cb = arguments[_i++]

  conditionExpr = args[0]
  timeout = args[1]
  poll = args[2]

  timeout = timeout or 1000
  poll = poll or 100
  protocol.safeExecuteAsync.apply _this, [ waitForConditionInBrowserJsScript, [ conditionExpr, timeout, poll ], (err, res) ->
    return cb(err)  if err?
    return cb("waitForConditionInBrowser failure for: " + conditionExpr)  unless res is true
    cb null, res
   ]

module.exports = protocol
